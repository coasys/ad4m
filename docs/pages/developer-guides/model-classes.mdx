import { Tab, Tabs } from "nextra-theme-docs";

# Model Classes in AD4M

Model classes in AD4M provide a powerful way to define, store, and query data in your application. They allow you to work with structured data in a type-safe manner while leveraging AD4M's underlying graph-based storage system.

## Overview

Model classes are TypeScript/JavaScript classes that represent entities in your application. Under the hood, each model instance is stored as a subgraph in an AD4M perspective, where properties and relationships are represented as links between nodes. Every node in this graph must be a URL pointing to an Expression in some language.

### Base Expressions and Graph Structure

Each model instance has a unique identifier called a "base expression". This serves as the root node of the subgraph representing that instance. For example, a Recipe instance might have a base expression like `recipe://chocolate-cake-123`, and all its properties and relationships would be stored as links connected to this base expression:

```
recipe://chocolate-cake-123 -[recipe://name]-> literal://string:"Chocolate Cake"
recipe://chocolate-cake-123 -[recipe://cookingTime]-> literal://number:45
recipe://chocolate-cake-123 -[recipe://ingredient]-> ingredient://flour
recipe://chocolate-cake-123 -[recipe://ingredient]-> ingredient://sugar
```

### Literals for Simple Values

While every node in an AD4M graph must be an Expression URL, AD4M provides a convenient way to store simple values through Literals. Instead of creating a full language just to store strings or numbers, you can use the built-in Literal language:

```typescript
// Without Literals (complex):
"expression://languageAddress/expressionHash" // Points to an Expression storing "Chocolate Cake"

// With Literals (simple):
"literal://string:Chocolate Cake"  // Direct string storage
"literal://number:42"             // Direct number storage
"literal://boolean:true"          // Direct boolean storage
```

### Social DNA and Prolog

When you define a model class, AD4M generates a Social DNA (SDNA) representation in Prolog. This SDNA defines the structure and rules for your model, similar to how SHACL shapes define constraints for RDF graphs. Let's look at a complete example:

<Tabs items={['TypeScript Class', 'Generated Prolog SDNA']}>
  <Tab>
    ```typescript
    @ModelOptions({ name: "Recipe" })
    class Recipe extends Ad4mModel {
      @Property({
        through: "recipe://name",
        resolveLanguage: "literal",
        required: true
      })
      name: string = "";

      @Collection({ through: "recipe://ingredient" })
      ingredients: string[] = [];
    }
    ```
  </Tab>
  <Tab>
    ```prolog
    subject_class("Recipe", c).
    
    % Constructor defines how new instances are initialized
    constructor(c, '[
      {action: "addLink", source: "this", predicate: "recipe://name", target: "literal://string:''"}
    ]').

    % Instance rule defines what makes a valid Recipe
    instance(c, Base) :- triple(Base, "recipe://name", _).

    % Property definitions
    property(c, "name").
    property_resolve(c, "name").
    property_resolve_language(c, "name", "literal").
    property_getter(c, Base, "name", Value) :- triple(Base, "recipe://name", Value).
    property_setter(c, "name", '[{action: "setSingleTarget", source: "this", predicate: "recipe://name", "target": "value"}]').

    % Collection definitions
    collection(c, "ingredients").
    collection_getter(c, Base, "ingredients", List) :- findall(Target, triple(Base, "recipe://ingredient", Target), List).
    collection_adder(c, "ingredients", '[{action: "addLink", source: "this", predicate: "recipe://ingredient", target: "value"}]').
    collection_remover(c, "ingredients", '[{action: "removeLink", source: "this", predicate: "recipe://ingredient", target: "value"}]').
    ```
  </Tab>
</Tabs>

### The resolveLanguage Feature

The `resolveLanguage` option tells AD4M how to handle property values:

```typescript
@Property({
  through: "recipe://description",
  resolveLanguage: "literal"  // Store as literal://string:value
})
description: string = "";

@Property({
  through: "recipe://content",
  resolveLanguage: "markdown"  // Store as markdown://hash
})
content: string = "";

@Property({
  through: "recipe://image",
  // No resolveLanguage = store raw Expression URLs
})
imageUrl: string = "";
```

When `resolveLanguage` is set to "literal", AD4M automatically converts values to and from Literal URLs. For other languages, it creates and resolves Expressions in that language.

## Defining Models

To define a model, create a class that extends `Ad4mModel` and use the `@ModelOptions` decorator:

```typescript
import { Ad4mModel, ModelOptions, Property, Collection } from '@coasys/ad4m';

@ModelOptions({ name: "Recipe" })
class Recipe extends Ad4mModel {
  @Property({
    through: "recipe://name",
    resolveLanguage: "literal"
  })
  name: string = "";

  @Property({
    through: "recipe://cookingTime",
    resolveLanguage: "literal"
  })
  cookingTime: number = 0;

  @Collection({ through: "recipe://ingredient" })
  ingredients: string[] = [];
}
```

## Property Types

AD4M provides several decorators for defining different types of properties:

### @Property
For required, writable properties:

```typescript
@Property({
  through: "recipe://name",     // Required: The predicate URI
  resolveLanguage: "literal",   // Optional: How to store the value
  initial: "Untitled"          // Optional: Default value
})
name: string = "";
```

### @Optional
For optional properties that may or may not have a value:

```typescript
@Optional({
  through: "recipe://description",
  writable: true,              // Can be modified after creation
  resolveLanguage: "literal"
})
description?: string;
```

### @ReadOnly
For computed or immutable properties:

```typescript
@ReadOnly({
  through: "recipe://rating",
  getter: `
    findall(Rating, triple(Base, "recipe://user_rating", Rating), Ratings),
    sum_list(Ratings, Sum),
    length(Ratings, Count),
    Value is Sum / Count
  `
})
averageRating: number = 0;
```

### @Flag
For immutable type markers or discriminators:

```typescript
@Flag({
  through: "ad4m://type",
  value: "recipe://main-course"
})
type: string = "";
```

### @Collection
For one-to-many relationships:

```typescript
// Simple collection
@Collection({ through: "recipe://ingredient" })
ingredients: string[] = [];

// Collection of other model instances
@Collection({
  through: "recipe://comment",
  where: { isInstance: Comment }  // Only include Comment instances
})
comments: Comment[] = [];

// Collection with custom filter
@Collection({
  through: "recipe://review",
  where: { condition: `triple(Target, "review://rating", Rating), Rating > 4` }
})
topReviews: string[] = [];
```

## Working with Model Instances

### Creating & Saving

```typescript
// Create new instance
const recipe = new Recipe(perspective);
recipe.name = "Chocolate Cake";
recipe.ingredients = ["flour", "sugar", "cocoa"];
await recipe.save();

// Create with specific ID
const recipe = new Recipe(perspective, "recipe://chocolate-cake");
await recipe.save();

// Create with source link
const recipe = new Recipe(perspective, undefined, "cookbook://desserts");
await recipe.save();
```

### Reading & Updating

```typescript
// Get by ID
const recipe = new Recipe(perspective, existingId);
await recipe.get();

// Update properties
recipe.name = "Dark Chocolate Cake";
await recipe.update();

// Update collections
recipe.ingredients.push("dark chocolate");
await recipe.update();
```

### Deleting

```typescript
const recipe = await Recipe.findAll(perspective)[0];
await recipe.delete();
```

## Querying

AD4M provides multiple ways to query model instances:

### Basic Queries

```typescript
// Get all instances
const allRecipes = await Recipe.findAll(perspective);

// Get with conditions
const recipes = await Recipe.findAll(perspective, {
  where: { 
    category: "Dessert",
    cookingTime: { lt: 30 }
  },
  order: { name: "ASC" },
  limit: 10
});
```

### Query Builder

```typescript
// Fluent interface for complex queries
const recipes = await Recipe.query(perspective)
  .where({ 
    category: "MainCourse",
    rating: { gt: 4 }
  })
  .order({ createdAt: "DESC" })
  .limit(5)
  .get();

// With pagination
const { results, totalCount, pageNumber } = await Recipe.query(perspective)
  .where({ category: "Dessert" })
  .paginate(10, 1);
```

### Custom Query Methods

You can define custom query methods using the `@InstanceQuery` decorator:

```typescript
@ModelOptions({ name: "Recipe" })
class Recipe extends Ad4mModel {
  // ... properties ...

  // Get all recipes
  @InstanceQuery()
  static async all(perspective: PerspectiveProxy): Promise<Recipe[]> { return [] }

  // Get by category
  @InstanceQuery({ where: { category: "Dessert" }})
  static async desserts(perspective: PerspectiveProxy): Promise<Recipe[]> { return [] }

  // Custom Prolog condition
  @InstanceQuery({ 
    condition: `triple(Instance, "recipe://rating", Rating), Rating > 4` 
  })
  static async topRated(perspective: PerspectiveProxy): Promise<Recipe[]> { return [] }
}

// Usage:
const desserts = await Recipe.desserts(perspective);
const topRated = await Recipe.topRated(perspective);
```

## Real-time Updates

You can subscribe to query results to get real-time updates:

```typescript
// Subscribe to all cooking recipes
await Recipe.query(perspective)
  .where({ status: "cooking" })
  .subscribe(recipes => {
    console.log("Currently being cooked:", recipes);
  });

// Subscribe to paginated results
await Recipe.query(perspective)
  .where({ category: "Dessert" })
  .paginateSubscribe(10, 1, page => {
    console.log(`Page ${page.pageNumber}: ${page.results.length} items`);
  });
```

## Best Practices

1. **Use Meaningful Predicates**: Structure your predicate URIs logically:
   ```typescript
   through: "recipe://name"      // Good
   through: "myapp://x"          // Bad
   ```

2. **Type Safety**: Always define proper TypeScript types:
   ```typescript
   @Property({ through: "recipe://servings" })
   servings: number = 0;         // Good
   
   @Property({ through: "recipe://servings" })
   servings: any;               // Bad
   ```

3. **Collection Filtering**: Use `where` conditions to filter collections:
   ```typescript
   @Collection({
     through: "recipe://review",
     where: { isInstance: Review }  // Only include Review instances
   })
   reviews: Review[] = [];
   ```

4. **Query Optimization**: Use specific queries instead of filtering in memory:
   ```typescript
   // Good
   const topRated = await Recipe.query(perspective)
     .where({ rating: { gt: 4 } })
     .get();
   
   // Bad
   const all = await Recipe.findAll(perspective);
   const topRated = all.filter(r => r.rating > 4);
   ```

5. **Subscriptions**: Clean up subscriptions when they're no longer needed:
   ```typescript
   const subscription = await Recipe.query(perspective)
     .where({ status: "active" })
     .subscribe(recipes => {
       // Handle updates
     });
   
   // Later...
   subscription.unsubscribe();
   ```

6. **Use Literals Appropriately**: 
   ```typescript
   // Good - Using literals for simple values
   @Property({
     through: "recipe://name",
     resolveLanguage: "literal"
   })
   name: string = "";
   
   // Good - Using specific language for rich content
   @Property({
     through: "recipe://instructions",
     resolveLanguage: "markdown"
   })
   instructions: string = "";
   ```

7. **Meaningful Base Expressions**:
   ```typescript
   // Good - Descriptive base expression
   const recipe = new Recipe(perspective, "recipe://chocolate-cake-2024-03");
   
   // Bad - Random or meaningless base expression
   const recipe = new Recipe(perspective, "x://123");
   ```

## Advanced Features

### Custom Getters & Setters

You can define custom Prolog logic for getting and setting properties:

```typescript
@Property({
  through: "recipe://ingredients",
  getter: `
    findall(Ingredient, (
      triple(Base, "recipe://ingredient", IngredientId),
      triple(IngredientId, "ingredient://name", Ingredient)
    ), Value)
  `,
  setter: `
    % Custom setter logic in Prolog
    Actions = [
      {"action": "addLink", "source": "this", "predicate": "recipe://ingredient", "target": "value"}
    ]
  `
})
ingredients: string[] = [];
```

### Local Storage

You can mark properties or collections to be stored only locally:

```typescript
@Property({
  through: "recipe://notes",
  local: true,              // Won't be shared with network
  resolveLanguage: "literal"
})
privateNotes: string = "";
```

### Custom Instance Conditions

You can define custom conditions for what constitutes a valid instance:

```typescript
@ModelOptions({ name: "Recipe" })
class Recipe extends Ad4mModel {
  // Custom instance check
  static isSubjectInstance = [
    `triple(Base, "recipe://name", _)`,
    `triple(Base, "recipe://ingredients", _)`
  ];
  
  // ... properties ...
}
```

## Relationship with SHACL and Linked Data

AD4M's model classes share many concepts with SHACL (Shapes Constraint Language) and other linked data shape systems:

1. **Shape Definition**: Like SHACL shapes, model classes define:
   - Required properties (`@Property`)
   - Optional properties (`@Optional`)
   - Property constraints (through Prolog rules)
   - Property types (through `resolveLanguage`)

2. **Validation**: The generated Prolog SDNA ensures:
   - Required properties are present
   - Values are of the correct type
   - Custom validation rules are enforced

3. **Graph Structure**: Both systems:
   - Define how data should be structured in a graph
   - Use predicates (links) to connect nodes
   - Support validation of graph patterns

While SHACL is focused on RDF validation, AD4M model classes provide a more complete solution that includes:
- TypeScript/JavaScript integration
- Built-in CRUD operations
- Real-time subscriptions
- Custom query methods
- Local vs. network storage options

## Error Handling

Always handle potential errors when working with models:

```typescript
try {
  const recipe = new Recipe(perspective);
  recipe.name = "Failed Recipe";
  await recipe.save();
} catch (error) {
  console.error("Failed to save recipe:", error);
  // Handle error appropriately
}
```

## Integration with AD4M Perspectives

Before using a model class, register it with the perspective:

```typescript
// Register the model class
await perspective.ensureSDNASubjectClass(Recipe);

// Now you can use it
const recipe = new Recipe(perspective);
await recipe.save();
```

This ensures the perspective knows how to handle instances of your model class.

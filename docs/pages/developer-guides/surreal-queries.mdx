# SurrealDB Queries in AD4M

AD4M now includes a powerful SurrealDB-based query engine that provides 10-100x faster performance compared to traditional Prolog queries. SurrealDB is used by default in `Ad4mModel` operations and can be accessed directly for advanced graph traversal queries.

## Why SurrealDB?

SurrealDB brings several key advantages:

- **Performance**: 10-100x faster than Prolog for most queries
- **Familiar Syntax**: SQL-like query language (SurrealQL)
- **Graph Traversal**: Native support for complex graph queries with `->` and `<-` operators
- **Aggregations**: Built-in support for COUNT, SUM, AVG, GROUP BY, etc.
- **Scalability**: Optimized for large datasets

## Default Behavior

**Important**: `Ad4mModel` now uses SurrealDB by default for all query operations. This means:

- `findAll()` uses SurrealDB automatically
- `findAllAndCount()` uses SurrealDB automatically  
- Query builder methods use SurrealDB automatically
- Live query subscriptions use SurrealDB automatically

You can still use Prolog queries by explicitly passing `useSurrealDB: false` if needed for backward compatibility.

## Direct SurrealDB Queries

For advanced use cases, you can execute SurrealQL queries directly using `perspective.querySurrealDB()`:

### Basic Query

```typescript
// Get all links
const links = await perspective.querySurrealDB('SELECT * FROM link');
console.log(links);
// [
//   { source: "user://alice", predicate: "follows", target: "user://bob", ... },
//   { source: "post://123", predicate: "likes", target: "user://alice", ... }
// ]
```

### Filtering

```typescript
// Filter links by predicate
const follows = await perspective.querySurrealDB(
  "SELECT * FROM link WHERE predicate = 'follows'"
);

// Multiple conditions
const recentLikes = await perspective.querySurrealDB(
  "SELECT * FROM link WHERE predicate = 'likes' AND timestamp > '2024-01-01T00:00:00Z'"
);
```

### Aggregations

```typescript
// Count links by predicate
const stats = await perspective.querySurrealDB(
  "SELECT predicate, count() as total FROM link GROUP BY predicate"
);
// [
//   { predicate: "follows", total: 42 },
//   { predicate: "likes", total: 156 }
// ]

// Average, sum, min, max
const metrics = await perspective.querySurrealDB(
  "SELECT count() as total_links, count(DISTINCT source) as unique_sources, count(DISTINCT author) as unique_authors FROM link"
);
```

## Graph Traversal Queries

SurrealDB uses efficient graph traversal with indexed node lookups. The key is to use **direct field comparisons** rather than subqueries for optimal performance.

### ⚠️ Performance Warning: Avoid Subqueries

**Important**: Subqueries (using `IN (SELECT ...)`) can be very slow, especially with large datasets. Instead, use direct graph traversal patterns with the `in.uri` and `out.uri` fields which are optimized and indexed.

```typescript
// ❌ SLOW - Uses subquery
const bad = await perspective.querySurrealDB(
  "SELECT * FROM link WHERE source IN (SELECT target FROM link WHERE source = 'user://alice')"
);

// ✅ FAST - Direct graph traversal (see multi-hop pattern below)
const good = await perspective.querySurrealDB(
  "SELECT * FROM link WHERE in.uri = 'user://alice' AND predicate = 'follows'"
);
```

### Graph Traversal Operators

SurrealDB stores links as graph edges with indexed source (`in.uri`) and target (`out.uri`) node references:

- `in.uri` - The source node of the link (where the edge comes FROM)
- `out.uri` - The target node of the link (where the edge goes TO)  
- `source` / `target` - String fields (also available for simple filtering)

### Forward Traversal (Outgoing Links)

```typescript
// Find all users that Alice follows
const aliceFollows = await perspective.querySurrealDB(
  "SELECT target FROM link WHERE in.uri = 'user://alice' AND predicate = 'follows'"
);

// Find all posts by Alice
const alicePosts = await perspective.querySurrealDB(
  "SELECT target FROM link WHERE in.uri = 'user://alice' AND predicate = 'author'"
);
```

### Reverse Traversal (Incoming Links)

```typescript
// Find all users who follow Alice (followers)
const aliceFollowers = await perspective.querySurrealDB(
  "SELECT source FROM link WHERE out.uri = 'user://alice' AND predicate = 'follows'"
);

// Find all posts that mention Alice
const mentionsAlice = await perspective.querySurrealDB(
  "SELECT source FROM link WHERE out.uri = 'user://alice' AND predicate = 'mentions'"
);
```

### Bidirectional Queries

```typescript
// Find all users connected to Alice (either following or followed by)
const aliceConnections = await perspective.querySurrealDB(
  "SELECT source, target FROM link WHERE (in.uri = 'user://alice' OR out.uri = 'user://alice') AND predicate = 'follows'"
);
```

### Multi-Hop Traversal

For multi-hop queries, break them into steps in your application code rather than using subqueries:

```typescript
// ✅ EFFICIENT: Multi-hop traversal in application code
// Step 1: Get friends
const friends = await perspective.querySurrealDB(
  "SELECT target FROM link WHERE in.uri = 'user://alice' AND predicate = 'follows'"
);

// Step 2: Get friends of friends
const friendsOfFriends = new Set();
for (const friend of friends) {
  const fof = await perspective.querySurrealDB(
    `SELECT target FROM link WHERE in.uri = '${friend.target}' AND predicate = 'follows'`
  );
  fof.forEach(f => friendsOfFriends.add(f.target));
}
```

### Complex Graph Patterns

```typescript
// Find all comments on Alice's posts
// Step 1: Get Alice's posts
const alicePosts = await perspective.querySurrealDB(
  "SELECT target FROM link WHERE in.uri = 'user://alice' AND predicate = 'authored'"
);

// Step 2: Get comments on those posts
const comments = [];
for (const post of alicePosts) {
  const postComments = await perspective.querySurrealDB(
    `SELECT source, target FROM link WHERE in.uri = '${post.target}' AND predicate = 'has_comment'`
  );
  comments.push(...postComments);
}

// Find mutual followers (two-step approach)
// Step 1: Who does Alice follow?
const aliceFollowing = await perspective.querySurrealDB(
  "SELECT target FROM link WHERE in.uri = 'user://alice' AND predicate = 'follows'"
);

// Step 2: Of those, who follows Alice back?
const mutuals = [];
for (const user of aliceFollowing) {
  const followsBack = await perspective.querySurrealDB(
    `SELECT source FROM link WHERE in.uri = '${user.target}' AND out.uri = 'user://alice' AND predicate = 'follows'`
  );
  if (followsBack.length > 0) mutuals.push(user.target);
}
```

### Filtering by Properties

```typescript
// Find all links from Alice with a specific timestamp range
const recentLinks = await perspective.querySurrealDB(
  "SELECT * FROM link WHERE in.uri = 'user://alice' AND timestamp > '2024-01-01T00:00:00Z' AND timestamp < '2024-12-31T23:59:59Z'"
);

// Find links by author
const bobsLinks = await perspective.querySurrealDB(
  "SELECT * FROM link WHERE author = 'did:key:bob' AND predicate = 'posted'"
);
```

## Using SurrealDB with Ad4mModel

`Ad4mModel` uses SurrealDB by default for all operations, providing significant performance improvements:

### findAll() - Default Uses SurrealDB

```typescript
@ModelOptions({ name: "Recipe" })
class Recipe extends Ad4mModel {
  @Property({ through: "recipe://name", resolveLanguage: "literal" })
  name: string = "";

  @Property({ through: "recipe://rating", resolveLanguage: "literal" })
  rating: number = 0;
}

// Uses SurrealDB automatically (default)
const allRecipes = await Recipe.findAll(perspective);

// With filters (still uses SurrealDB)
const highRated = await Recipe.findAll(perspective, {
  where: { rating: { gt: 4 } },
  order: { rating: "DESC" },
  limit: 10
});

// Explicitly use Prolog (for backward compatibility)
const recipesProlog = await Recipe.findAll(perspective, {}, false);
```

### Query Builder - Default Uses SurrealDB

```typescript
// Query builder uses SurrealDB by default
const recipes = await Recipe.query(perspective)
  .where({ rating: { gt: 4 } })
  .order({ rating: "DESC" })
  .limit(10)
  .get();

// Explicitly enable SurrealDB (redundant since it's default)
const recipesSurreal = await Recipe.query(perspective)
  .where({ rating: { gt: 4 } })
  .useSurrealDB(true)  // Default is true
  .get();

// Explicitly use Prolog
const recipesProlog = await Recipe.query(perspective)
  .where({ rating: { gt: 4 } })
  .useSurrealDB(false)  // Switch to Prolog
  .get();
```

### Live Query Subscriptions

Subscriptions also benefit from SurrealDB's performance:

```typescript
// Subscribe using SurrealDB (default)
await Recipe.query(perspective)
  .where({ rating: { gt: 4 } })
  .subscribe((recipes) => {
    console.log("Updated high-rated recipes:", recipes);
  });

// Subscribe using Prolog
await Recipe.query(perspective)
  .where({ rating: { gt: 4 } })
  .useSurrealDB(false)
  .subscribe((recipes) => {
    console.log("Updated recipes (Prolog):", recipes);
  });
```

### findAllAndCount()

```typescript
// Uses SurrealDB by default
const { results, totalCount } = await Recipe.findAllAndCount(perspective, {
  where: { rating: { gt: 3 } },
  limit: 10,
  offset: 0
});
console.log(`Showing ${results.length} of ${totalCount} recipes`);

// Use Prolog explicitly
const { results, totalCount } = await Recipe.findAllAndCount(
  perspective, 
  { where: { rating: { gt: 3 } } },
  false  // useSurrealDB = false
);
```

## Performance Comparison

Here's what you can expect from SurrealDB vs Prolog:

| Operation | Prolog | SurrealDB | Speed-up |
|-----------|--------|-----------|----------|
| Find all (1000 items) | ~500ms | ~5ms | **100x** |
| Complex where query | ~800ms | ~15ms | **53x** |
| Aggregation (count) | ~600ms | ~8ms | **75x** |
| Graph traversal (3 hops) | ~1200ms | ~25ms | **48x** |

*Benchmarks on typical datasets. Actual performance varies by query complexity and data size.*

## Advanced SurrealQL Features

### Grouping and Aggregation

```typescript
// Find posts with more than 10 likes
const popularPosts = await perspective.querySurrealDB(
  "SELECT out.uri as post, count() as like_count FROM link WHERE predicate = 'likes' GROUP BY out.uri HAVING like_count > 10"
);

// Count followers per user
const followerCounts = await perspective.querySurrealDB(
  "SELECT out.uri as user, count() as followers FROM link WHERE predicate = 'follows' GROUP BY out.uri ORDER BY followers DESC"
);
```

### DISTINCT Values

```typescript
// Get all unique predicates used
const predicates = await perspective.querySurrealDB(
  "SELECT DISTINCT predicate FROM link"
);

// Get unique authors
const authors = await perspective.querySurrealDB(
  "SELECT DISTINCT author FROM link"
);
```

### Sorting and Pagination

```typescript
// Recent links first, paginated
const recentLinks = await perspective.querySurrealDB(
  "SELECT * FROM link ORDER BY timestamp DESC LIMIT 20 START 0"
);

// Next page
const nextPage = await perspective.querySurrealDB(
  "SELECT * FROM link ORDER BY timestamp DESC LIMIT 20 START 20"
);
```

### String Operations

```typescript
// Find links with predicates containing "follow"
const followLinks = await perspective.querySurrealDB(
  "SELECT * FROM link WHERE predicate CONTAINS 'follow'"
);

// Case-insensitive search
const searchResults = await perspective.querySurrealDB(
  "SELECT * FROM link WHERE string::lowercase(predicate) CONTAINS 'like'"
);
```

## Security Note

**Important**: `querySurrealDB()` only allows read-only operations for security reasons. The following operations are blocked:

- ❌ `DELETE` - Use `perspective.remove()` instead
- ❌ `UPDATE` - Use `perspective.update()` instead  
- ❌ `INSERT` / `CREATE` - Use `perspective.add()` instead
- ❌ `DROP` / `DEFINE` - Not applicable to link data

Allowed operations:
- ✅ `SELECT` - Query data
- ✅ `RETURN` - Return expressions
- ✅ Aggregations (`COUNT`, `SUM`, `AVG`, etc.)
- ✅ Graph traversal operators

If you need to modify links, use the standard AD4M methods:
```typescript
// Adding links
await perspective.add({ source: "user://alice", predicate: "follows", target: "user://bob" });

// Removing links  
await perspective.remove({ source: "user://alice", predicate: "follows", target: "user://bob" });
```

## Migration from Prolog

If you have existing code using Prolog queries, here's how to migrate:

### Before (Prolog)

```typescript
const results = await perspective.infer(
  'triple(Post, "likes", User), triple(User, "follows", "user://alice")'
);
```

### After (SurrealDB - Multi-Step Approach)

```typescript
// Step 1: Find users who follow Alice
const followers = await perspective.querySurrealDB(
  "SELECT source as User FROM link WHERE out.uri = 'user://alice' AND predicate = 'follows'"
);

// Step 2: Find posts liked by those users
const results = [];
for (const follower of followers) {
  const posts = await perspective.querySurrealDB(
    `SELECT source as Post, target as User FROM link WHERE in.uri = '${follower.User}' AND predicate = 'likes'`
  );
  results.push(...posts);
}
```

### Ad4mModel Migration

Good news! If you're using `Ad4mModel`, you don't need to change anything:

```typescript
// This automatically uses SurrealDB now (no code changes needed!)
const recipes = await Recipe.findAll(perspective, {
  where: { rating: { gt: 4 } }
});
```

If you need Prolog for backward compatibility:

```typescript
// Explicitly use Prolog
const recipes = await Recipe.findAll(perspective, {
  where: { rating: { gt: 4 } }
}, false); // useSurrealDB = false
```

## When to Use Which?

### Use SurrealDB (Default) When:
- ✅ You need fast queries (most cases)
- ✅ You're using `Ad4mModel` (automatic)
- ✅ You need graph traversal
- ✅ You need aggregations and analytics
- ✅ You have large datasets

### Use Prolog When:
- ⚠️ You have complex custom SDNA rules
- ⚠️ You need backward compatibility with existing code
- ⚠️ You're using advanced Prolog-specific features
- ⚠️ You need logic programming capabilities

## Best Practices

1. **Avoid Subqueries**: Never use `IN (SELECT ...)` patterns - they're very slow. Use multi-step queries in application code instead
2. **Use Graph Traversal Fields**: Leverage `in.uri` and `out.uri` for indexed, fast lookups
3. **Use Ad4mModel**: Let it handle query generation automatically with SurrealDB
4. **Multi-Hop in Code**: Break multi-hop traversals into separate queries in your application code
5. **Limit Results**: Always use `LIMIT` for large result sets
6. **Combine Filters**: Use multiple WHERE conditions in one query instead of separate queries
7. **Profile Performance**: Use browser DevTools to measure query performance
8. **Index Awareness**: The system automatically indexes `in.uri`, `out.uri`, `predicate`, `source`, and `target`

## Examples Repository

For more examples, check out these real-world use cases:

- **Social Graph**: Finding connections and recommendations
- **Content Discovery**: Filtering and ranking posts
- **Analytics Dashboard**: Aggregating metrics and statistics
- **Hierarchical Data**: Navigating tree structures

See the [AD4M examples repository](https://github.com/coasys/ad4m-examples) for complete implementations.

## Related Resources

- [Model Classes Guide](/developer-guides/model-classes) - Using Ad4mModel with SurrealDB
- [Perspectives](/perspectives) - Understanding perspectives and links
- [Social DNA](/social-dna) - Advanced query patterns with SDNA
- [SurrealDB Documentation](https://surrealdb.com/docs) - Complete SurrealQL reference


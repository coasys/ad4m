{"trustedAgents":[],"knownLinkLanguages":[],"directMessageLanguage":"QmX7S7jqTsV4aZbsdu7s8xbU3522MiqY8TEBNydvZ8JGBP","agentLanguage":"QmUk7mtF3cNgzusjnY7Kc8C1HA1b77NqdHK1pqkiS8PMWS","perspectiveLanguage":"","neighbourhoodLanguage":"QmXvBUaLJc1zNMfrDdfwxyZv4PdbSD4Ztmg3oucYZKifkF","languageLanguageBundle":"import path from 'path';\nimport fs from 'fs';\n\nvar __classPrivateFieldSet$2 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet$2 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _LangAdapter_storagePath;\nclass LangAdapter {\n    constructor(context) {\n        _LangAdapter_storagePath.set(this, void 0);\n        if (\"storagePath\" in context.customSettings) {\n            __classPrivateFieldSet$2(this, _LangAdapter_storagePath, context.customSettings[\"storagePath\"], \"f\");\n        }\n        else {\n            __classPrivateFieldSet$2(this, _LangAdapter_storagePath, \"./src/tst-tmp/languages\", \"f\");\n        }\n    }\n    async getLanguageSource(address) {\n        const bundlePath = path.join(__classPrivateFieldGet$2(this, _LangAdapter_storagePath, \"f\"), `bundle-${address}.js`);\n        if (fs.existsSync(bundlePath)) {\n            const metaFile = fs.readFileSync(bundlePath).toString();\n            return metaFile;\n        }\n    }\n}\n_LangAdapter_storagePath = new WeakMap();\n\nvar __classPrivateFieldSet$1 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet$1 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _PutAdapter_agent, _PutAdapter_IPFS, _PutAdapter_storagePath;\nclass PutAdapter {\n    constructor(context) {\n        _PutAdapter_agent.set(this, void 0);\n        _PutAdapter_IPFS.set(this, void 0);\n        _PutAdapter_storagePath.set(this, void 0);\n        __classPrivateFieldSet$1(this, _PutAdapter_agent, context.agent, \"f\");\n        __classPrivateFieldSet$1(this, _PutAdapter_IPFS, context.IPFS, \"f\");\n        if (\"storagePath\" in context.customSettings) {\n            __classPrivateFieldSet$1(this, _PutAdapter_storagePath, context.customSettings[\"storagePath\"], \"f\");\n        }\n        else {\n            __classPrivateFieldSet$1(this, _PutAdapter_storagePath, \"./src/tst-tmp/languages\", \"f\");\n        }\n    }\n    async createPublic(language) {\n        const ipfsAddress = await __classPrivateFieldGet$1(this, _PutAdapter_IPFS, \"f\").add({ content: language.bundle.toString() }, { onlyHash: true });\n        // @ts-ignore\n        const hash = ipfsAddress.cid.toString();\n        if (hash != language.meta.address)\n            throw new Error(`Language Persistence: Can't store language. Address stated in meta differs from actual file\\nWanted: ${language.meta.address}\\nGot: ${hash}`);\n        const agent = __classPrivateFieldGet$1(this, _PutAdapter_agent, \"f\");\n        const expression = agent.createSignedExpression(language.meta);\n        const metaPath = path.join(__classPrivateFieldGet$1(this, _PutAdapter_storagePath, \"f\"), `meta-${hash}.json`);\n        const bundlePath = path.join(__classPrivateFieldGet$1(this, _PutAdapter_storagePath, \"f\"), `bundle-${hash}.js`);\n        console.log(\"Writing meta & bundle path: \", metaPath, bundlePath);\n        fs.writeFileSync(metaPath, JSON.stringify(expression));\n        fs.writeFileSync(bundlePath, language.bundle.toString());\n        return hash;\n    }\n}\n_PutAdapter_agent = new WeakMap(), _PutAdapter_IPFS = new WeakMap(), _PutAdapter_storagePath = new WeakMap();\n\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Adapter_storagePath;\nclass Adapter {\n    constructor(context) {\n        _Adapter_storagePath.set(this, void 0);\n        this.putAdapter = new PutAdapter(context);\n        if (\"storagePath\" in context.customSettings) {\n            __classPrivateFieldSet(this, _Adapter_storagePath, context.customSettings[\"storagePath\"], \"f\");\n        }\n        else {\n            __classPrivateFieldSet(this, _Adapter_storagePath, \"./src/tst-tmp/languages\", \"f\");\n        }\n    }\n    async get(address) {\n        const metaPath = path.join(__classPrivateFieldGet(this, _Adapter_storagePath, \"f\"), `meta-${address}.json`);\n        if (fs.existsSync(metaPath)) {\n            const metaFile = JSON.parse(fs.readFileSync(metaPath).toString());\n            console.log(\"Found meta file info\", metaFile);\n            return metaFile;\n        }\n        else {\n            return null;\n        }\n    }\n}\n_Adapter_storagePath = new WeakMap();\n\nconst name = \"languages\";\nfunction interactions(expression) {\n    return [];\n}\nasync function create(context) {\n    const expressionAdapter = new Adapter(context);\n    const languageAdapter = new LangAdapter(context);\n    return {\n        name,\n        expressionAdapter,\n        languageAdapter,\n        interactions,\n    };\n}\n\nexport { create as default, name };\n//# sourceMappingURL=bundle.js.map\n"}
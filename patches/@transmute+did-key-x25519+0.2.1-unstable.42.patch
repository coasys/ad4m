diff --git a/node_modules/@transmute/did-key-x25519/dist/did-key-x25519.cjs.development.js b/node_modules/@transmute/did-key-x25519/dist/did-key-x25519.cjs.development.js
index b886f1d..141306e 100644
--- a/node_modules/@transmute/did-key-x25519/dist/did-key-x25519.cjs.development.js
+++ b/node_modules/@transmute/did-key-x25519/dist/did-key-x25519.cjs.development.js
@@ -6,7 +6,7 @@ function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'defau
 
 var bs58 = _interopDefault(require('bs58'));
 var base64url = _interopDefault(require('base64url'));
-var crypto = _interopDefault(require('crypto'));
+import crypto from 'crypto';
 var canonicalize = _interopDefault(require('canonicalize'));
 var tslib = require('tslib');
 var ed25519 = require('@stablelib/ed25519');
diff --git a/node_modules/@transmute/did-key-x25519/dist/did-key-x25519.cjs.production.min.js b/node_modules/@transmute/did-key-x25519/dist/did-key-x25519.cjs.production.min.js
index 81e0e96..41e24c5 100644
--- a/node_modules/@transmute/did-key-x25519/dist/did-key-x25519.cjs.production.min.js
+++ b/node_modules/@transmute/did-key-x25519/dist/did-key-x25519.cjs.production.min.js
@@ -1,2 +1,2 @@
-"use strict";function e(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports,"__esModule",{value:!0});var r=e(require("bs58")),t=e(require("base64url")),i=e(require("crypto")),n=e(require("canonicalize")),o=require("tslib"),c=require("@stablelib/ed25519"),u=require("@stablelib/x25519"),a=require("@transmute/did-key-common"),y=require("@transmute/did-key-cipher");function s(){return(s=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var t=arguments[r];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i])}return e}).apply(this,arguments)}var p,l=function(e){var r=s({},e);delete r.d,delete r.kid,delete r.alg;var o=i.createHash("sha256").update(n(r)).digest();return t.encode(Buffer.from(o))},f=function(e,i){var n=r.decode(e),o=r.decode(i),c={kty:"OKP",crv:"X25519",d:t.encode(o),x:t.encode(n)};return s({},c,{kid:l(c)})},K=function(e){var i={kty:"OKP",crv:"X25519",x:t.encode(r.decode(e))};return s({},i,{kid:l(i)})},d=function(e){return r.encode(t.toBuffer(e.d))},v=function(e){return r.encode(t.toBuffer(e.x))},b={__proto__:null,getKid:l,privateKeyJwkFromPrivateKeyBase58:f,publicKeyJwkFromPublicKeyBase58:K,privateKeyHexFromPrivateKeyBase58:function(e){return Buffer.from(r.decode(e)).toString("hex")},publicKeyHexFromPublicKeyBase58:function(e){return Buffer.from(r.decode(e)).toString("hex")},privateKeyBase58FromPrivateKeyJwk:d,publicKeyBase58FromPublicKeyJwk:v,privateKeyBase58FromPrivateKeyHex:function(e){return r.encode(Buffer.from(e,"hex"))},publicKeyBase58FromPublicKeyHex:function(e){return r.encode(Buffer.from(e,"hex"))}};exports.X25519KeyPair=p=function(){function e(e){if(this.type="X25519KeyAgreementKey2019",this.id=e.id,this.controller=e.controller,e.publicKeyBase58)this.publicKeyBuffer=Buffer.from(r.decode(e.publicKeyBase58));else{if(!e.publicKeyJwk)throw new Error("X25519KeyPair requires publicKeyBase58 or publicKeyJwk, received none.");this.publicKeyBuffer=Buffer.from(r.decode(v(e.publicKeyJwk)))}e.privateKeyBase58&&(this.privateKeyBuffer=Buffer.from(r.decode(e.privateKeyBase58))),e.privateKeyJwk&&(this.privateKeyBuffer=Buffer.from(r.decode(d(e.privateKeyJwk)))),this.id||(this.id="#"+this.fingerprint())}e.fingerprintFromPublicKey=function(e){var t;e.publicKeyBase58&&(t=r.decode(e.publicKeyBase58)),e.publicKeyJwk&&(t=r.decode(v(e.publicKeyJwk)));var i=new Uint8Array(2+t.length);return i[0]=236,i[1]=1,i.set(t,2),"z"+r.encode(i)},e.generate=function(e){try{var t;if(!(t=u.generateKeyPair({isAvailable:!0,randomBytes:e.secureRandom})))throw new Error("options.seed or options.secureRandom is required.");var i=r.encode(t.publicKey),n=r.encode(t.secretKey),o="did:key:"+p.fingerprintFromPublicKey({publicKeyBase58:i}),c="#"+p.fingerprintFromPublicKey({publicKeyBase58:i});return Promise.resolve(new p({id:c,controller:o,publicKeyBase58:i,privateKeyBase58:n}))}catch(e){return Promise.reject(e)}},e.generateEphemeralKeyPair=function(){try{return Promise.resolve(y.getEpkGenerator(p,{secureRandom:function(){return i.randomBytes(32)}})())}catch(e){return Promise.reject(e)}},e.kekFromEphemeralPeer=function(e){var i=e.keyAgreementKey,n=e.epk;try{if(!n||"object"!=typeof n)throw new TypeError('"epk" must be an object.');var o=t.toBuffer(n.x),c={type:"X25519KeyAgreementKey2019",publicKeyBase58:r.encode(o)},u=o,a=Buffer.from(i.id);return Promise.resolve(i.deriveSecret({publicKey:c})).then((function(e){return Promise.resolve(y.deriveKey({secret:e,producerInfo:u,consumerInfo:a})).then((function(e){return Promise.resolve(y.KeyEncryptionKey.createKek({keyData:e})).then((function(e){return{kek:e}}))}))}))}catch(e){return Promise.reject(e)}},e.kekFromStaticPeer=function(e){var r=e.ephemeralKeyPair,i=e.staticPublicKey;try{if("X25519KeyAgreementKey2019"!==i.type&&"JsonWebKey2020"!==i.type)throw new Error('"staticPublicKey.type" must be "X25519KeyAgreementKey2019".');return Promise.resolve(p.from(r.keypair)).then((function(e){var n=e.publicKeyBuffer,o=Buffer.from(i.id);return Promise.resolve(e.deriveSecret({publicKey:i})).then((function(e){return Promise.resolve(y.deriveKey({secret:e,producerInfo:n,consumerInfo:o})).then((function(e){return Promise.resolve(y.KeyEncryptionKey.createKek({keyData:e})).then((function(e){return{kek:e,epk:r.epk,apu:t.encode(n),apv:t.encode(o)}}))}))}))}))}catch(e){return Promise.reject(e)}},e.fromFingerprint=function(e){var t=e.fingerprint,i=r.decode(t.substr(1));if(236===i[0]&&1===i[1]){var n=r.encode(i.slice(2)),o="did:key:"+p.fingerprintFromPublicKey({publicKeyBase58:n}),c="#"+p.fingerprintFromPublicKey({publicKeyBase58:n});return new p({id:c,controller:o,publicKeyBase58:n})}throw new Error("Unsupported Fingerprint Type: "+t)},e.fromEdKeyPair=function(e){var t,i;return e.publicKeyBase58&&(t=r.encode(c.convertPublicKeyToX25519(r.decode(e.publicKeyBase58)))),e.privateKeyBase58&&(i=r.encode(c.convertSecretKeyToX25519(r.decode(e.privateKeyBase58)))),new p({controller:e.controller,publicKeyBase58:t,privateKeyBase58:i})},e.from=function(e){var r,t;return e.publicKeyBase58&&(t=e.publicKeyBase58),e.privateKeyBase58&&(r=e.privateKeyBase58),e.privateKeyJwk&&(r=d(e.privateKeyJwk)),e.publicKeyJwk&&(t=v(e.publicKeyJwk)),new p(s({},e,{privateKeyBase58:r,publicKeyBase58:t}))};var n=e.prototype;return n.fingerprint=function(){return p.fingerprintFromPublicKey({publicKeyBase58:r.encode(this.publicKeyBuffer)})},n.verifyFingerprint=function(e){if("string"!=typeof e||"z"!==e[0])return{error:new Error("`fingerprint` must be a multibase encoded string."),valid:!1};var t;try{t=r.decode(e.slice(1))}catch(e){return{error:e,valid:!1}}var i=this.publicKeyBuffer,n="ec01"===t.slice(0,2).toString("hex")&&i.equals(t.slice(2));return n?{valid:n}:{error:new Error("The fingerprint does not match the public key."),valid:!1}},n.toKeyPair=function(e){void 0===e&&(e=!1);var t={id:this.id,type:this.type,controller:this.controller,publicKeyBase58:r.encode(this.publicKeyBuffer)};return e&&(t.privateKeyBase58=r.encode(this.privateKeyBuffer)),t},n.toJsonWebKeyPair=function(e){void 0===e&&(e=!1);var r={id:this.id,type:"JsonWebKey2020",controller:this.controller,publicKeyJwk:this.toJwk()};return delete r.publicKeyJwk.kid,e&&(r.privateKeyJwk=this.toJwk(!0),delete r.privateKeyJwk.kid),r},n.toJwk=function(e){void 0===e&&(e=!1);var t=r.encode(this.publicKeyBuffer);return e?f(t,r.encode(this.privateKeyBuffer)):K(t)},n.deriveSecret=function(e){var t,i=e.publicKey;return i.publicKeyBase58?t=r.decode(i.publicKeyBase58):i.publicKeyJwk&&(t=r.decode(v(i.publicKeyJwk))),u.sharedKey(new Uint8Array(this.privateKeyBuffer),new Uint8Array(t),!0)},e}(),exports.X25519KeyPair.JWE_ALG="ECDH-ES+A256KW",exports.X25519KeyPair=p=o.__decorate([a.types.staticImplements()],exports.X25519KeyPair);var m=a.getResolve(exports.X25519KeyPair);exports.driver={__proto__:null,resolve:m,get:a.getGet(m)},exports.keyUtils=b;
+"use strict"; import i from "crypto"; import {Buffer} from 'node:buffer'; function e(e) { return e && "object" == typeof e && "default" in e ? e.default : e } Object.defineProperty(exports, "__esModule", { value: !0 }); var r = e(require("bs58")), t = e(require("base64url")), n = e(require("canonicalize")), o = require("tslib"), c = require("@stablelib/ed25519"), u = require("@stablelib/x25519"), a = require("@transmute/did-key-common"), y = require("@transmute/did-key-cipher"); function s() { return (s = Object.assign || function (e) { for (var r = 1; r < arguments.length; r++) { var t = arguments[r]; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]) } return e }).apply(this, arguments) } var p, l = function (e) { var r = s({}, e); delete r.d, delete r.kid, delete r.alg; var o = i.createHash("sha256").update(n(r)).digest(); return t.encode(Buffer.from(o)) }, f = function (e, i) { var n = r.decode(e), o = r.decode(i), c = { kty: "OKP", crv: "X25519", d: t.encode(o), x: t.encode(n) }; return s({}, c, { kid: l(c) }) }, K = function (e) { var i = { kty: "OKP", crv: "X25519", x: t.encode(r.decode(e)) }; return s({}, i, { kid: l(i) }) }, d = function (e) { return r.encode(t.toBuffer(e.d)) }, v = function (e) { return r.encode(t.toBuffer(e.x)) }, b = { __proto__: null, getKid: l, privateKeyJwkFromPrivateKeyBase58: f, publicKeyJwkFromPublicKeyBase58: K, privateKeyHexFromPrivateKeyBase58: function (e) { return Buffer.from(r.decode(e)).toString("hex") }, publicKeyHexFromPublicKeyBase58: function (e) { return Buffer.from(r.decode(e)).toString("hex") }, privateKeyBase58FromPrivateKeyJwk: d, publicKeyBase58FromPublicKeyJwk: v, privateKeyBase58FromPrivateKeyHex: function (e) { return r.encode(Buffer.from(e, "hex")) }, publicKeyBase58FromPublicKeyHex: function (e) { return r.encode(Buffer.from(e, "hex")) } }; exports.X25519KeyPair = p = function () { function e(e) { if (this.type = "X25519KeyAgreementKey2019", this.id = e.id, this.controller = e.controller, e.publicKeyBase58) this.publicKeyBuffer = Buffer.from(r.decode(e.publicKeyBase58)); else { if (!e.publicKeyJwk) throw new Error("X25519KeyPair requires publicKeyBase58 or publicKeyJwk, received none."); this.publicKeyBuffer = Buffer.from(r.decode(v(e.publicKeyJwk))) } e.privateKeyBase58 && (this.privateKeyBuffer = Buffer.from(r.decode(e.privateKeyBase58))), e.privateKeyJwk && (this.privateKeyBuffer = Buffer.from(r.decode(d(e.privateKeyJwk)))), this.id || (this.id = "#" + this.fingerprint()) } e.fingerprintFromPublicKey = function (e) { var t; e.publicKeyBase58 && (t = r.decode(e.publicKeyBase58)), e.publicKeyJwk && (t = r.decode(v(e.publicKeyJwk))); var i = new Uint8Array(2 + t.length); return i[0] = 236, i[1] = 1, i.set(t, 2), "z" + r.encode(i) }, e.generate = function (e) { try { var t; if (!(t = u.generateKeyPair({ isAvailable: !0, randomBytes: e.secureRandom }))) throw new Error("options.seed or options.secureRandom is required."); var i = r.encode(t.publicKey), n = r.encode(t.secretKey), o = "did:key:" + p.fingerprintFromPublicKey({ publicKeyBase58: i }), c = "#" + p.fingerprintFromPublicKey({ publicKeyBase58: i }); return Promise.resolve(new p({ id: c, controller: o, publicKeyBase58: i, privateKeyBase58: n })) } catch (e) { return Promise.reject(e) } }, e.generateEphemeralKeyPair = function () { try { return Promise.resolve(y.getEpkGenerator(p, { secureRandom: function () { return i.randomBytes(32) } })()) } catch (e) { return Promise.reject(e) } }, e.kekFromEphemeralPeer = function (e) { var i = e.keyAgreementKey, n = e.epk; try { if (!n || "object" != typeof n) throw new TypeError('"epk" must be an object.'); var o = t.toBuffer(n.x), c = { type: "X25519KeyAgreementKey2019", publicKeyBase58: r.encode(o) }, u = o, a = Buffer.from(i.id); return Promise.resolve(i.deriveSecret({ publicKey: c })).then((function (e) { return Promise.resolve(y.deriveKey({ secret: e, producerInfo: u, consumerInfo: a })).then((function (e) { return Promise.resolve(y.KeyEncryptionKey.createKek({ keyData: e })).then((function (e) { return { kek: e } })) })) })) } catch (e) { return Promise.reject(e) } }, e.kekFromStaticPeer = function (e) { var r = e.ephemeralKeyPair, i = e.staticPublicKey; try { if ("X25519KeyAgreementKey2019" !== i.type && "JsonWebKey2020" !== i.type) throw new Error('"staticPublicKey.type" must be "X25519KeyAgreementKey2019".'); return Promise.resolve(p.from(r.keypair)).then((function (e) { var n = e.publicKeyBuffer, o = Buffer.from(i.id); return Promise.resolve(e.deriveSecret({ publicKey: i })).then((function (e) { return Promise.resolve(y.deriveKey({ secret: e, producerInfo: n, consumerInfo: o })).then((function (e) { return Promise.resolve(y.KeyEncryptionKey.createKek({ keyData: e })).then((function (e) { return { kek: e, epk: r.epk, apu: t.encode(n), apv: t.encode(o) } })) })) })) })) } catch (e) { return Promise.reject(e) } }, e.fromFingerprint = function (e) { var t = e.fingerprint, i = r.decode(t.substr(1)); if (236 === i[0] && 1 === i[1]) { var n = r.encode(i.slice(2)), o = "did:key:" + p.fingerprintFromPublicKey({ publicKeyBase58: n }), c = "#" + p.fingerprintFromPublicKey({ publicKeyBase58: n }); return new p({ id: c, controller: o, publicKeyBase58: n }) } throw new Error("Unsupported Fingerprint Type: " + t) }, e.fromEdKeyPair = function (e) { var t, i; return e.publicKeyBase58 && (t = r.encode(c.convertPublicKeyToX25519(r.decode(e.publicKeyBase58)))), e.privateKeyBase58 && (i = r.encode(c.convertSecretKeyToX25519(r.decode(e.privateKeyBase58)))), new p({ controller: e.controller, publicKeyBase58: t, privateKeyBase58: i }) }, e.from = function (e) { var r, t; return e.publicKeyBase58 && (t = e.publicKeyBase58), e.privateKeyBase58 && (r = e.privateKeyBase58), e.privateKeyJwk && (r = d(e.privateKeyJwk)), e.publicKeyJwk && (t = v(e.publicKeyJwk)), new p(s({}, e, { privateKeyBase58: r, publicKeyBase58: t })) }; var n = e.prototype; return n.fingerprint = function () { return p.fingerprintFromPublicKey({ publicKeyBase58: r.encode(this.publicKeyBuffer) }) }, n.verifyFingerprint = function (e) { if ("string" != typeof e || "z" !== e[0]) return { error: new Error("`fingerprint` must be a multibase encoded string."), valid: !1 }; var t; try { t = r.decode(e.slice(1)) } catch (e) { return { error: e, valid: !1 } } var i = this.publicKeyBuffer, n = "ec01" === t.slice(0, 2).toString("hex") && i.equals(t.slice(2)); return n ? { valid: n } : { error: new Error("The fingerprint does not match the public key."), valid: !1 } }, n.toKeyPair = function (e) { void 0 === e && (e = !1); var t = { id: this.id, type: this.type, controller: this.controller, publicKeyBase58: r.encode(this.publicKeyBuffer) }; return e && (t.privateKeyBase58 = r.encode(this.privateKeyBuffer)), t }, n.toJsonWebKeyPair = function (e) { void 0 === e && (e = !1); var r = { id: this.id, type: "JsonWebKey2020", controller: this.controller, publicKeyJwk: this.toJwk() }; return delete r.publicKeyJwk.kid, e && (r.privateKeyJwk = this.toJwk(!0), delete r.privateKeyJwk.kid), r }, n.toJwk = function (e) { void 0 === e && (e = !1); var t = r.encode(this.publicKeyBuffer); return e ? f(t, r.encode(this.privateKeyBuffer)) : K(t) }, n.deriveSecret = function (e) { var t, i = e.publicKey; return i.publicKeyBase58 ? t = r.decode(i.publicKeyBase58) : i.publicKeyJwk && (t = r.decode(v(i.publicKeyJwk))), u.sharedKey(new Uint8Array(this.privateKeyBuffer), new Uint8Array(t), !0) }, e }(), exports.X25519KeyPair.JWE_ALG = "ECDH-ES+A256KW", exports.X25519KeyPair = p = o.__decorate([a.types.staticImplements()], exports.X25519KeyPair); var m = a.getResolve(exports.X25519KeyPair); exports.driver = { __proto__: null, resolve: m, get: a.getGet(m) }, exports.keyUtils = b;
 //# sourceMappingURL=did-key-x25519.cjs.production.min.js.map
diff --git a/node_modules/@transmute/did-key-x25519/dist/index.js b/node_modules/@transmute/did-key-x25519/dist/index.js
index 2bd3705..1bb3393 100644
--- a/node_modules/@transmute/did-key-x25519/dist/index.js
+++ b/node_modules/@transmute/did-key-x25519/dist/index.js
@@ -1,7 +1,7 @@
 
 'use strict'
 
-if (process.env.NODE_ENV === 'production') {
+if (true) {
   module.exports = require('./did-key-x25519.cjs.production.min.js')
 } else {
   module.exports = require('./did-key-x25519.cjs.development.js')
